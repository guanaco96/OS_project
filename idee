1) memory leaks check con valgrind

------------------------------------------------------------------------------------------------------
2) controllo finale anti-plagio KIT -- MIO -- FLAVIO

------------------------------------------------------------------------------------------------------
3) messaggi di errore == "too many fds || //TODELETE answering some failure"

------------------------------------------------------------------------------------------------------
4) **********************STATO*****ATTUALE***************

	readHeader ci da "connection reset by peers"
	evidentemente ci sono delle race conditions
	leggere bene il test prima di iniziare a debuggare
	dirottare provvisoriamente "use" del client su qualcosa di meno ingombrante
	

------------------------------------------------------------------------------------------------------
5) KNOWN BUGS:
i) send all invia anche a se stesso, non è un problema imho.

ii) i file inviati si accumulano ad infinitum sul disco della macchina.

iii) BUG DEL CLIENT: in execute_receive, quando l'argomento di -R è < 0, 
non c'è modo di arrestare il loop che stampa infinite copie se non resti-
tuendo errore anche quando una read mi ritorna 0 (== EOF).
HO MODIFICATO IL CLIENT

------------------------------------------------------------------------------------------------------
6) TODECLARE:
i) ho cambiato il file in testconf.sh sostituendo chattylib.a
con chatty, che giustamente supera il limite dei 50Kb per ottenere gli 
errori voluti dal test. (Analogamente ho fatto per teststress.sh e per
testleaks.sh)


------------------------------------------------------------------------------------------------------
7) ATTENZIONE AL FLUSSO DI CONTROLLO: se gestisco gli errori devo
 sempre unlockare i mutex altrimenti rischio di andaee in deadlock
 ogni volta che gestisco errori.

------------------------------------------------------------------------------------------------------
8) RIVEDERE L'ATOMICITA' per write/read, ad esempio in connections.c 
flavio fa una cosa (forse) più furba di quella che faccio io, lui
controlla di aver letto tutti i bytes e in caso contrario riavvia la
lettura. 

-------------------------------------------------------------------------------------------------------------
9) LAMENTELE: il client stampa il numero delle operazioni in modo 
inconsistente quando queste falliscono e quando queste hanno successo:
nel primo caso stampa il numero definito in op_t mentre nel secondo
stampa la posizione dell'operazione tra le richieste del client.
Questo ha reso il debugging un po' noioso prima di scoprirlo.












